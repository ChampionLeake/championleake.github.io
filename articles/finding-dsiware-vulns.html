<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="ChampionLeake : ">

    <link rel="stylesheet" type="text/css" media="screen" href="../stylesheets/stylesheet.css">

    <title>Finding DSiWare vulns</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/ChampionLeake">View on GitHub</a>

          <h1 id="project_title"><img src="../avatar.png" width="100" height="100" align="top"> <u>ChampionLeake</u></h1>
          <h2 id="project_tagline"></h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="hello-there" class="anchor" href="#hello-there" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction:</h1>
<p>I noticed that there were some questions about how some reverse-engineers or hackers found exploitable vulns in DSiWare applications. I also noticed that there weren't any write-ups or documentation that involved discovering DSiWare application flaws. 
<br>
<br>
But today, I wanted to be able to explain how you could be able to find vulnerabilities in DSiWare applications <b><u>(If there are any to pop)</u></b>. It'll save people time to have no need to ask if a game is vulnerable or not. Plus, I think this could be a good introduction to learn how to get into exploiting applications or games. Without no further interruptions or side-bar conversations, let's get started :D</p>

<h1>
<a id="hello-there" class="anchor" href="#hello-there" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Things to know:</h1>
<p>To get things out of the way, you need know some things before you get started. 
<ul>
<li>A crash doesn't mean that it's automatically exploitable. Of course, the crash might be exploitable, but if it doesn't overwritten parts of the stack registers, it's not likely to be exploitable, but that will be covered later on in the article.</li>
<li>I'll only be covering stack smashing flaws since it's the easiest to start-off with and I'm familiar with these type of vulnerablities to explain what they are. I suggest that you look up how stack smashing works. There's an overview on this topic on<a href="https://cturt.github.io/DS-exploit-finding.html">CTurt's DS-exploit-finding guide works</a> (Or I can google it for you <a href-"http://lmgtfy.com/?q=how+does+stack+smashing+work">Here</a>)</li>
<li>You must know that the DSi uses a ARM Processor. R0-R12 are generally based use for calculation as the last 3, R13(SP = Stack Pointer), R14(LR = Link Register), and R15(PC = Program Counter) are unique. You can find more details on these registers <a href="https://problemkaputt.de/gbatek.htm#armcpuregisterset">here</a>!</li>
</ul>
</p>

<h1>
<a id="hello-there" class="anchor" href="#hello-there" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tools I used:</h1>
<p>Now let's move on! You'll need the right equipment/tools to be able to get throught this article. Here's the tools I used for the purpose of this article. 
<ul>
<li><a href="https://problemkaputt.de/gba.htm">NO$GBA</a> - It's a really useful debugging emulator which can emulate your DSi NAND.</li>
<li><a href="https://github.com/WinterMute/twltool">TWLTool</a> - You'll definitely need this to be able to decrypt/encrypt your DSi NAND. That way, you can edit the NAND with the save you're injecting for NO$GBA.</li>
<li><a href="https://dsi.cfw.guide">HiyaCFW(Optional)</a> - This makes it easy to actually pull your savedata as the SD is your NAND. (This is optional though)
<li><a href="https://dsi.cfw.guide/assets/files/fwTool.nds">FWTOOL</a> - This will be useful for dumping your NAND so you can use it for NO$GBA to debug/emulate your DSi. (You'll need homebrew access)
<li><a href="https://mh-nexus.de/en/hxd/">HxD</a> - I use this hex editor a lot and it has useful analysis features that we'll use in this guide.</li>
<li><a href="https://www.cjmweb.net/vbindiff/">VBinDiff</a> - I use this to mostly compare files next to each other. This will help find the differences in a DSiWare savefile for checksums, different names or other garbage tbh :/</li>
<li><a href="https://www.osforensics.com/tools/mount-disk-images.html">OSFMount</a> - This tool will be useful for mounting the public.sav file to reveal basically the real save. Although the save is in the public.sav but it's useful to just mount the file and take what's in it to observe and then put it back.</li>
<li>Money - You'll need it to buy these games you don't have.</li>
</ul>
</p>

<h1>
<a id="hello-there" class="anchor" href="#hello-there" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Picking a target:</h1>
<p>For the sake of this article, I'll be looking for stack smashing vulnerabilities in DSiWare applications. I would start with games that have profile names or some type of username-input. It doesn't have to be strictly profile names but there are some games that allow putting in your name as you reached a high-score, like Fieldrunners. Even if the string is 3 bytes long, you can still try. 
<br><br>
So, I'm going to use a simple game called "WordSearcher" that I already looked at. It's not vulnerable, but it's useful for a really good example. So remember what to look for:
<ul>
<li>Look at list of <a href="http://dsibrew.org/wiki/DSiWare_VulnList">examined DSiWare titles</a> before you start. Don't waste your time if you're looking into finding new flaws.</li>
<li>Profile names that allow you to create a custom name</li>
<li>Games with highscores that allows a custom name</li>
<li>Avoid some games with multiple elements (some RPGs) unless you like the challenge for checksums. Some may not have too many checksums but it's recommended to start simple.</li>
</ul>
It shouldn't be a challenge to pick a title to observe. I'll also be looking at Fieldrunners to show you what it looks like to find a useful flaw.
</p>

<h1>
<a id="hello-there" class="anchor" href="#hello-there" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting past Checksums:</h1>
<p>Checksums/Sums plays a huge role for certain games or applications. For those of you who do not know what checksums are, allow me to break it down for you. 
<br><br>
The word, "Check", should ring a bell. The word "Sum" is like a number or a byte. Maybe adding if you're a mathematician. So if you really put those 2 meanings together, you can tell they're checking something. But for what purpose? It's to ensure a file or a section in a file is not corrupted or tampered with. Without checksums, programs/applications would be extremly vulnerable to simple attacks.
<br><br>
With checksums, editing a savefile without actually patching those checksum bytes will ensure the game deletes and rewrites the save. So that's what we need to take care of before we start editing whatever we please. Let's create some saves and compare them so we can locate the checksum(s) for "WordSearcher". It's common for some DSiWare titles to use a familiar CRC algorithm which gives you a greater chance to patch checksums easily with <a href="https://mh-nexus.de/en/hxd/">HxD</a> or other checksum calculators.
<br><br>
So, I'm going to create 2 savefiles (two public.sav). One will contain the username "AAAAAAAA", and the other will contain "AAAAAAAB". We'll eventually use <a href="https://www.cjmweb.net/vbindiff/">VBinDiff</a> to compare the two files and look for differences. We first have to fetch the real save that's mounted within the "public.sav" file. this can be done with <a href="https://www.osforensics.com/tools/mount-disk-images.html">OSFMount</a> or any program taht can mount disk images.
<br><br><br>
You must have DSi NAND dump (that you dumped yourself). <a href="https://github.com/Wintermute">Wintermute's</a> <a href="https://dsi.cfw.guide/assets/files/fwTool.nds">FWTOOL 2.0.0</a> homebrew application should help you dump your NAND. The last thing you'll need your DSi's CID and ConsoleID, which you can look at <a href=https://gbatemp.net/threads/dsi-downgrading-the-complete-guide.393682/">Gadorach's downgrading guide</a> to obtain these things.
<br><br>I assume that you already have the things you need, I'll quickly go over what you need to do when mounting your NAND to fetch the public.sav(s).
<ul>
Your NAND needs to be decrypted before any mounting should occur.
<li>Open up "OSFMount"</li>
<li>Select "Mount New..."</li>
<li>Click the "..." button to the right of "Image file".</li>
<li>Find your DSi's NAND and select "Partition 0".</li>
<li>Then click OK</li>
</ul>
Your set up should look like the screenshot below.
<img src="../articles/assets/OSFMount_SetUp.JPG">
Now you should be able to open your mounted NAND and look for the correct titleid for your corresponding DSiWare title from "/title/0030004/TITLEID/data/. Copy the "public.sav" file somewhere safe.<br><br>
You can basically repeat the whole process. Create a new save with a different name, dump your NAND again, decrypted your NAND, mount your NAND, and then find the "public.sav" again. I still suggest renaming those files to stay organized. After your done you can still rename it to it's original name. Let's now move onto mounting our savefiles.
<ul>
<li>Open up "OSFMount"</li>
<li>Select "Mount New..."</li>
<li>Click the "..." button to the right of "Image file".</li>
<li>Find the "public.sav" (or the renamed savefile), I renamed the "public.sav"(s) to "AAAAAAAA.sav" and "AAAAAAAB.sav" for the purpose of this article.</li>
<li>Un-check the "Read-Only drive" box and check the "Mount as removeable media" option</li>
<li>Click "Ok" and you should be ready to go.</li>
</ul>
Copy the file that's mounted from the savefile and place it somewhere safe. Repeat the whole process to the other savefile as well.
<img src="../articles/assets/OSFMount_ScreenShot.JPG">
<br>
We can now move onto using VBinDiff to compare the two savefiles.
<br><br>
Select the two files and drag it to the program VBinDiff gave us this.
<img src="../articles/assets/VBinDiff-ScreenShot.JPG">
<img src="../articles/assets/VBinDiff-ScreenShot2.JPG">
<br>
As you noticed from these two screenshot, we seemed to have found the differences in these saves by pressing Enter or manually scrolling. At offset 0x0 for both files, it seems we might be dealing with CRC32 considering that it's 4 bytes long. CRC8/Sum would be 1 byte long and CRC16/Checksum-16 would be 2 bytes. So since we now know where the checksum is, we're going to start investigating what happens if we change it or why those byets came to that outcome. Let's begin to open our save in <a href="https://mh-nexus.de/en/hxd/">HxD</a>
<br><br>
So going back to where I mentioned that HxD has really useful features like analysis, this is where we're going to atempt to use HxD's tools to figure out if the checksum is using a classical-polynomial algorithm or it's using a custom custom algorithm. I'll only cover classical polynomial since custom checksum algorithms requires dumping the games code and using any disassembler to reverse engineer the code to find that CRC function. I don't know how to do that but we'll be doing something else that I'm calling this the <a href="https://github.com/WemI0">Weml0Sum</a> as he was the first to atually teach me this cool trick. It's really use.
<br><br>
What is the 'WemI0Sum' method? It's a method to easily have a chance to patch checksums and or a way to determine in a game uses a classical-polynomial algorithm or not. This method consists on highlighting blocks/chunks of a the save and use a CRC analyzer with he appropriate sum calculation of course. It's more time consuming and it's a bit because if you don't have much reverse-engineering experience, the WemI0Sum is a go. So let's try it with these saves we have.
<br><br>
Since we're now open in HxD, I selected basically after the first for byte, which is our checksum, all the way to the end of the file. It's highly simple and with this method, it may take an hour or all day to find the perfect area where the checksum will change or be affected. But take a look at the screenshot how things should look like if you followed along.
<img src="../articles/assets/HxD-ScreenShot.JPG">
<br>
Now this is where the 'WemI0Sum' will determine if this game is using a classical-polynomial or not.
<ul>
<li>So you have your selected area so you need to navigate to "Analysis"</li>
<li>From there, select the "Checksums..." option.</li>
<li>Be sure to choose the appropriate algorithm. In that case for this game, it uses CRC32/Checksum-32 so I select CRC first and pressed 'OK'</li>
</ul>
<img src="../articles/assets/HxD-ScreenShot2.JPG">
I want you know to tell yourself, what do you notice in the yellow highlighted areas of the screenshot above? If you guess it, THE RESULTS ARE THE SAME BUT IT'S BACKWARDS. That's good since the checksum is in little-endian, reversed bytes.
<br>
Notice how the bytes "C2 EC 62 15" in the save is reverse by "15 62 EC C2". So let's take this to the test and look at the other file to make sure our reading is accurate.
<img src="../articles/assets/HxD-ScreenShot3.JPG">
Once again, the bytes seem to be identical but in little-endian. We can confirm from here that the game does indeedly use a familiar CRC32 polynomial algorithm. Now from there, you can basically use an open source CRC patcher, edit the offsets a bit and use it as a CRCFixer for your game. We finally cracked the checksum of this game and we can now move on to the next section. Also, not all games will be easy with this method as I explained earlier. You'll have to disassemble the game's code and reverse-engineer the checksum function itself if the Weml0Sum doesn't work.
</p>

<h1>
<a id="hello-there" class="anchor" href="#hello-there" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Attempting an overflow:</h1>
<p>If you maade it this far, congratulations, you're finally ready to go ahead of edit the game's savefile and look for potential overflows. WordSearcher's profile name ascends to 8-bytes long. Let's try to see what would happen if we used an extensive string. I like using extensive "AAs" since it's easier for me to look at the registers if any are verwritten with those strings.
<img src="../articles/assets/HxD-ScreenShot4.JPG">
I think what we have should be enough to do some damage to the application. Once you're done adding a long string or editing the save, do the 'Welm0Sum' method to correct the checksums so it doesn't come up as corrupt when you open it.
<br><br>
Rename the savefile back to its original name (game_user.bin) and you can basically copy and paste the file back into the public.sav while OSFMount was open. Once things are done, you're free to "Dismount all & Exit" the program. (Click OK if there's a warning).
<br><br>
You'll need to decrypt your NAND and inject the save to it's original spot and re-encrypt the NAND to test it in NO$GBA. You can find the tutorial for that <a href="https://gbatemp.net/threads/dsi-downgrading-the-complete-guide.393682/">here</a> under the "Decrypting your NAND" spoiler.
<br><br>
Once our NAND is back to being encrypted, we can now try to emulate our NAND in NO$GBA. I won't go over how to set up the NAND to use for NO$GBA since there are tutorials elsewhere to look into.
<br><br>
Open up NO$GBA and select any game from the dirrectoy you have your roms placed. You should on the DSi Menu, now we can test to see if we get a crash from our attempted overflow.
<center><img src="../articles/assets/Inital-Overflow-ScreenShot.JPG"></center>
<br>
ON REAL HARDWARE, this part of the game would freeze and crash the DSi, let's see if this would happen on NO$GBA to test our overflow attempt.
<img src="../articles/assets/Inital-Overflow-ScreenShot2.JPG">
If you already paid attention from what I said earlier in the guide about this game, you know it's not being vulnerable. NO$GBA doesn't seem to have any error pop-ups or any registers in the highlighted regions to be overwritten. So from there, you could try other methods. 
<br><br>
So if the profile string isn't vulnerable we can still improvise, we can try the crossword levels itself maybe. The crossword levels in this game is plaintext, which is a big no-no. Anyway, let's try it. We first have to make crossword data.
<img src="../articles/assets/HxD-ScreenShot5.JPG">
Instead of AA(s), I changed things up to be BB(s). We used an exetensive large string for one of the crossword levels. The crosswords levels applies to the regular profile name checksum so the Welm0Sum would work. Now we just have to test it.
<br><br>
We test it in NO$GBA again there seems to be no errors but custom/non-existant strings n the crossword board. No overflows and this type of bug is not exploitable. 
<img src="../articles/assets/Inital-Overflow-ScreenShot3.JPG">
So now let me show you what NO$GBA would look like if you got a useful crash for Fieldrunners. You can tell if the game crashed if NO$GBA error popped up and if you look at the highlighted area, some of the registers are overwritten with AA(s). If R15(The PC) is overwritten as well, you have yourself an exploitable application.
<img src="../articles/assets/Overflow-Example.JPG">
</p>

<h1>
<a id="hello-there" class="anchor" href="#hello-there" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Closing:</h1>
<p>So I hope this article/writeup gave you an overview on how to find vulnerabilities in DSiWare applications. Hopefully I can update this article to include more things to cover like reverse-engineering the checksums and maybe other things. If you ever have any questions, you can let me know on my <a href="https://discord.gg/w4SKAr8">Discord Server</a> and I'll try my best to answer all of your questions. 
<br><br>
Hopefully I can probably get a writeup about porting NDS-HBMenu for exploitable games. Anyways, I'm suprised you made it this far considering how long this article is. I hope you learned something today at least.
</p>

<h1>
<a id="hello-there" class="anchor" href="#hello-there" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Credits:</h1>
I would like to thank all of the following below:
<ul>
<li>NoCash - For creating no$gba and for the excellent documentation</li>
<li>WinterMute - For creating the tools FWTOOL and TWLTool</li>
<li>Weml0 - For teaching me the 'WemI0Sum' method</li>
<li>CTurt - Inspiration of his DS-exploit-finding guide</li>
<li>Jerbear64 & emiyl - For the DSiCFW guide</li>
</ul>
If you're not on this list and I forgot to add you, let me know.
      </section>
    </div>
    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
    
  </body>
</html>
